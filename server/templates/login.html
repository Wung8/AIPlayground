{% extends "base.html" %}

{% block styles %}
  <link rel="stylesheet" href="{{ url_for('static', filename='css/login.css') }}">
{% endblock %}

{% block content %}
<div class="login-page">
  <canvas id="boids-canvas"></canvas>

  <div class="login-wrap">

    <!-- Login -->
    <form class="auth-card" method="POST" action="{{ url_for('login') }}">
      {{ login_form.hidden_tag() }}
      <div class="auth-title">Log in</div>
      
      <div class="auth-field">
        <label class="auth-label" for="{{ login_form.email.id }}">Email</label>
        {{ login_form.email(class="auth-input", type="email") }}
      </div>

      <div class="auth-field">
        <label class="auth-label" for="{{ login_form.password.id }}">Password</label>
        {{ login_form.password(class="auth-input", type="password") }}
      </div>

      <label class="auth-remember">
        {{ login_form.remember() }}
        Remember Me
      </label>

      {{ login_form.submit(class="auth-btn") }}
    </form>

    <!-- Register -->
    <form class="auth-card" method="POST" action="{{ url_for('login') }}">
      {{ register_form.hidden_tag() }}
      <div class="auth-title">Register</div>

      <div class="auth-field">
        <label class="auth-label" for="{{ register_form.username.id }}">Username</label>
        {{ register_form.username(class="auth-input") }}
      </div>

      <div class="auth-field">
        <label class="auth-label" for="{{ register_form.email.id }}">Email</label>
        {{ register_form.email(class="auth-input", type="email") }}
      </div>

      <div class="auth-field">
        <label class="auth-label" for="{{ register_form.password.id }}">Password</label>
        {{ register_form.password(class="auth-input", type="password") }}
      </div>

      <div class="auth-field">
        <label class="auth-label" for="{{ register_form.confirm_password.id }}">Repeat Password</label>
        {{ register_form.confirm_password(class="auth-input", type="password") }}
      </div>

      {{ register_form.submit(class="auth-btn") }}
    </form>

  </div>
</div>
{% endblock %}

{% block scripts %}
<!-- ================= BOIDS SIM ================= -->

<script>
const canvas = document.getElementById("boids-canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - 78;
}
window.addEventListener("resize", resize);
resize();

/* ===========================
   PARAMETERS (LIVE TUNABLE)
=========================== */

const params = {
  vision: 100,
  alignmentForce: 0.05,
  cohesionForce: 0.1,
  separationForce: 0.2,
  minSpeed: 1.0,
  maxSpeed: 4.0,
  drag: 0.005,
  randomness: 1.1,
  margin: 120,
  turnfactor: 0.15
};

/* ===========================
   TOROIDAL DISTANCE
=========================== */

function toroidalDelta(a, b, max) {
  let d = b - a;
  if (Math.abs(d) > max / 2) {
    d -= Math.sign(d) * max;
  }
  return d;
}

/* ===========================
   BOID CLASS
=========================== */

const BOID_COUNT = 20;
const boids = [];

class Boid {
  constructor() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    const angle = Math.random() * Math.PI * 2;
    this.vx = Math.cos(angle) * params.minSpeed;
    this.vy = Math.sin(angle) * params.minSpeed;

    const a = (Math.random()-0.6);
    const b = (Math.random()-0.6);
    const c = (Math.random()-0.6);
    this.alignMul = params.alignmentForce + a * 0.15;
    this.cohMul   = params.cohesionForce + b * 0.15;
    this.sepMul   = params.separationForce + c * 0.15;
  }

  update() {
    let alignX = 0, alignY = 0;
    let cohX = 0, cohY = 0;
    let sepX = 0, sepY = 0;
    let total = 0;

    for (let other of boids) {
      if (other === this) continue;

      const dx = toroidalDelta(this.x, other.x, canvas.width);
      const dy = toroidalDelta(this.y, other.y, canvas.height);
      const dist = Math.hypot(dx, dy);

      if (dist < params.vision) {
        const dx_s = dx / params.vision;
        const dy_s = dy / params.vision;

        alignX += other.vx;
        alignY += other.vy;

        cohX += dx_s * (1 - dist/params.vision);
        cohY += dy_s * (1 - dist/params.vision);

        sepX -= dx_s * (1 - dist/params.vision);
        sepY -= dy_s * (1 - dist/params.vision);

        total++;
      }
    }

    if (total > 0) {
      alignX /= total;
      alignY /= total;

      cohX /= total;
      cohY /= total;
    }

    this.vx += sepX * this.sepMul;
    this.vy += sepY * this.sepMul;

    this.vx += (alignX - this.vx) * this.alignMul;
    this.vy += (alignY - this.vy) * this.alignMul;

    this.vx += (cohX - this.vx) * this.cohMul;
    this.vy += (cohY - this.vy) * this.cohMul;

    this.vx += (Math.random() - 0.5) * params.randomness * 0.05;
    this.vy += (Math.random() - 0.5) * params.randomness * 0.05;

    if (this.x < params.margin) {
      this.vx += (params.margin - this.x) / params.margin * params.turnfactor;
    }
    if (this.x > canvas.width - params.margin) {
      this.vx -= (this.x - (canvas.width - params.margin)) / params.margin * params.turnfactor;
    }
    if (this.y < params.margin) {
      this.vy += (params.margin - this.y) / params.margin * params.turnfactor;
    }
    if (this.y > canvas.height - params.margin) {
      this.vy -= (this.y - (canvas.height - params.margin)) / params.margin * params.turnfactor;
    }

    let speed = Math.hypot(this.vx, this.vy);

    if (speed > params.maxSpeed) {
      this.vx = (this.vx / speed) * params.maxSpeed;
      this.vy = (this.vy / speed) * params.maxSpeed;
    }

    if (speed < params.minSpeed) {
      this.vx = (this.vx / speed) * params.minSpeed;
      this.vy = (this.vy / speed) * params.minSpeed;
    }

    this.vx *= (1 - params.drag);
    this.vy *= (1 - params.drag);

    this.x += this.vx;
    this.y += this.vy;

    if (this.x < 0) this.x += canvas.width;
    if (this.x > canvas.width) this.x -= canvas.width;
    if (this.y < 0) this.y += canvas.height;
    if (this.y > canvas.height) this.y -= canvas.height;
  }

  draw() {
    const size = 12;

    const speed = Math.hypot(this.vx, this.vy);
    const dirX = this.vx / (speed || 1);
    const dirY = this.vy / (speed || 1);

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();

    ctx.moveTo(this.x + dirX * size, this.y + dirY * size);
    ctx.lineTo(this.x - dirX * size - dirY * size * 0.6, this.y - dirY * size + dirX * size * 0.6);
    ctx.lineTo(this.x - dirX * size + dirY * size * 0.6, this.y - dirY * size - dirX * size * 0.6);

    ctx.closePath();
    ctx.fill();
  }
}

for (let i = 0; i < BOID_COUNT; i++) boids.push(new Boid());

function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  for (let b of boids) {
    b.update();
    b.draw();
  }
  requestAnimationFrame(animate);
}
animate();
</script>
{% endblock %}